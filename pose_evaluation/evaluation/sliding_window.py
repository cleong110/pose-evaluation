"""Given two poses, one longer, slide the smaller across the larger"""

import logging
import time
from abc import ABC, abstractmethod
from collections import defaultdict
from collections.abc import Sequence
from contextlib import contextmanager

from pose_evaluation.evaluation.score_dataframe_format import ScoreDFCol

logging.basicConfig(level=logging.INFO)
log = logging.getLogger(__name__)


@contextmanager
def timed_section(name: str):
    start = time.perf_counter()
    result = {}
    yield result
    end = time.perf_counter()
    duration = end - start
    result["duration"] = duration
    log.info(f"[TIMER] {name} took {duration:.2f} seconds.")


with timed_section("2-party imports"):
    import pandas as pd
    from pose_format import Pose
    from tqdm import tqdm

with timed_section("import construct metric"):
    pass

with timed_section("import dataset utils"):
    pass
with timed_section("import dataset_dfs code"):
    pass
with timed_section("import stuff"):
    from pose_evaluation.metrics.distance_metric import DistanceMetric
with timed_section("import pose utils"):
    from pose_evaluation.utils.pose_utils import pose_slice_frames


def get_sliding_window_frame_ranges(
    total_frames: int,
    window_length: int,
    stride: int,
    start: int = 0,
    end: int | None = None,
) -> list[tuple[int, int]]:
    """
    Generate a list of (start_frame, end_frame) tuples representing sliding windows over a sequence of frames.

    Each tuple defines a window of frames starting at `start_frame` and ending at `end_frame` (exclusive).
    Windows are generated by sliding from `start` to `end` using the given `stride`, and will not exceed `end`.

    If the final stride would go past `end`, a shorter window may be included at the end to ensure coverage
    of the final frames.

    Parameters
    ----------
        total_frames (int): Total number of frames in the pose sequence.
        window_length (int): Number of frames per window. Must be > 0.
        stride (int): Number of frames to move between successive windows. Must be > 0.
        start (int): Optional starting frame index. Default is 0.
        end (int | None): Optional end frame index (exclusive). If None, defaults to total_frames.

    Returns
    -------
        list[tuple[int, int]]: A list of (start, end) frame index pairs, where end is exclusive.

    Raises
    ------
        ValueError: If `end` exceeds `total_frames`, or if `window_length` or `stride` is not > 0.

    Example:
        >>> get_sliding_window_frame_ranges(total_frames=20, window_length=8, stride=6)
        [(0, 8), (6, 14), (12, 20)]

    """
    end = end if end is not None else total_frames

    if end > total_frames:
        raise ValueError(f"End index {end} exceeds pose length {total_frames}")
    if window_length <= 0 or stride <= 0:
        raise ValueError("window_length and stride must be > 0")

    ranges = []
    i = start
    while i < end:
        window_end = min(i + window_length, end)
        ranges.append((i, window_end))
        if window_end == end:
            break
        i += stride
    return ranges


def score_windows_from_ranges(
    query_pose: "Pose",
    target_pose: "Pose",
    windows: Sequence[tuple[int, int]],
    metric: "DistanceMetric",
) -> pd.DataFrame:
    """
    Scores a sequence of (start_frame, end_frame) windows between a query pose and
    slices of a target pose using the provided distance metric.

    Args:
        query_pose (Pose): The pose sequence to compare against.
        target_pose (Pose): The full target pose sequence to slice from.
        windows (Sequence[tuple[int, int]]): List of (start_frame, end_frame) tuples.
        metric (DistanceMetric): Scoring metric to apply.

    Returns:
        pd.DataFrame: DataFrame with columns:
            ['start_frame', 'end_frame', 'Time (s)', 'SCORE', 'TIME', 'SIGNATURE']

    """
    score_results = defaultdict(list)

    for start_idx, end_idx in tqdm(windows, desc="Scoring windows"):
        window_pose = pose_slice_frames(target_pose, start_idx, end_idx)

        score_start = time.perf_counter()
        score = metric.score_with_signature(query_pose, window_pose)
        scoring_duration = time.perf_counter() - score_start

        seconds = start_idx / target_pose.body.fps

        score_results["start_frame"].append(start_idx)
        score_results["end_frame"].append(end_idx)
        score_results["Time (s)"].append(seconds)
        score_results[ScoreDFCol.SCORE].append(score.score)
        score_results[ScoreDFCol.TIME].append(scoring_duration)
        score_results[ScoreDFCol.SIGNATURE].append(metric.get_signature().format())

    scores_df = pd.DataFrame(score_results)
    scores_df[ScoreDFCol.SIGNATURE] = scores_df[ScoreDFCol.SIGNATURE].astype("category")
    return scores_df


class SlidingWindowStrategy(ABC):
    def __init__(self, name: str = ""):
        self.name = name

    def get_name(self) -> str:
        return self.name

    @abstractmethod
    def get_windows(self, pose: Pose, start_frame: int, end_frame: int) -> list[tuple[int, int]]:
        """
        Given a pose and start/end frame indexes, return a list of (start, end) frame index pairs
        representing sliding windows between start_frame and end_frame.
        """
        pass


class FixedWindowsSetByQueryMeanLengthsStrategy(SlidingWindowStrategy):
    def __init__(
        self,
        mean_query_pose_length: int,
        window_length_multiplier: float = 1.2,
        stride_divisor: int | None = 3,
    ):
        """Set window length and stride based on mean query length and heuristics"""
        window_length = int(mean_query_pose_length * window_length_multiplier)
        if stride_divisor is None:
            stride_divisor = window_length  # aka, stride 1

        if stride_divisor <= 0:
            raise ValueError("stride_divisor must be a positive integer")

        stride = max(1, window_length // stride_divisor)

        self.window_length = window_length
        self.stride = stride

        strategy_name = f"FixedWindowFromMeanQueryLength(len={self.window_length})_mult{window_length_multiplier}_stridedivisor{stride_divisor}={self.stride})"

        super().__init__(name=strategy_name)

    def get_windows(self, pose: Pose, start_frame: int, end_frame: int) -> list[tuple[int, int]]:
        return get_sliding_window_frame_ranges(
            total_frames=len(pose.body.data),
            window_length=self.window_length,
            stride=self.stride,
            start=start_frame,
            end=end_frame,
        )


class FixedWindowStrategy(SlidingWindowStrategy):
    def __init__(self, window_length: int, stride: int):
        """
        Sliding window strategy that uses fixed window length and stride.

        Parameters
        ----------
            window_length (int): Number of frames in each window. Must be > 0.
            stride (int): Number of frames to move forward between windows. Must be > 0.

        """
        if window_length <= 0 or stride <= 0:
            raise ValueError("Both window_length and stride must be positive integers.")

        self.window_length = window_length
        self.stride = stride

        name = f"FixedWindow(len={self.window_length}, stride={self.stride})"
        super().__init__(name=name)

    def get_windows(self, pose: Pose, start_frame: int, end_frame: int) -> list[tuple[int, int]]:
        return get_sliding_window_frame_ranges(
            total_frames=len(pose.body.data),
            window_length=self.window_length,
            stride=self.stride,
            start=start_frame,
            end=end_frame,
        )
